{"ast":null,"code":"import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n} // A type of promise-like that resolves synchronously and supports only one observer\n\n\nconst _iteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\")) : \"@@iterator\";\n\nconst _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")) : \"@@asyncIterator\"; // Asynchronously call a function and send errors to recovery continuation\n\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nvar RecordState = Object.freeze({\n  START: 'start',\n  PAUSE: 'pause',\n  STOP: 'stop',\n  NONE: 'none'\n});\n\nvar AudioReactRecorder = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(AudioReactRecorder, _React$Component);\n\n  function AudioReactRecorder(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n\n    _this.init = function () {\n      try {\n        _this.leftchannel = [];\n        _this.rightchannel = [];\n        _this.recorder = null;\n        _this.recording = false;\n        _this.recordingLength = 0;\n        _this.volume = null;\n        _this.audioInput = null;\n        _this.sampleRate = null;\n        _this.AudioContext = window.AudioContext || window.webkitAudioContext;\n        _this.context = null;\n        _this.analyser = null;\n        _this.canvas = _this.canvasRef.current;\n        _this.canvasCtx = _this.canvas.getContext('2d');\n        _this.stream = null;\n        _this.tested = false;\n        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\n        return Promise.resolve();\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    _this.getStream = function (constraints) {\n      if (!constraints) {\n        constraints = {\n          audio: true,\n          video: false\n        };\n      }\n\n      return navigator.mediaDevices.getUserMedia(constraints);\n    };\n\n    _this.setUpRecording = function () {\n      _this.context = new _this.AudioContext();\n      _this.sampleRate = _this.context.sampleRate;\n      _this.volume = _this.context.createGain();\n      _this.audioInput = _this.context.createMediaStreamSource(_this.stream);\n      _this.analyser = _this.context.createAnalyser();\n\n      _this.audioInput.connect(_this.analyser);\n\n      var bufferSize = 2048;\n      _this.recorder = _this.context.createScriptProcessor(bufferSize, 2, 2);\n\n      _this.analyser.connect(_this.recorder);\n\n      _this.recorder.connect(_this.context.destination);\n\n      var self = _assertThisInitialized(_this);\n\n      _this.recorder.onaudioprocess = function (e) {\n        if (!self.recording) return;\n        var left = e.inputBuffer.getChannelData(0);\n        var right = e.inputBuffer.getChannelData(1);\n\n        if (!self.tested) {\n          self.tested = true;\n\n          if (!left.reduce(function (a, b) {\n            return a + b;\n          })) {\n            console.log('Error: There seems to be an issue with your Mic');\n            self.stop();\n            self.stream.getTracks().forEach(function (track) {\n              track.stop();\n            });\n            self.context.close();\n          }\n        }\n\n        self.leftchannel.push(new Float32Array(left));\n        self.rightchannel.push(new Float32Array(right));\n        self.recordingLength += bufferSize;\n      };\n\n      _this.visualize();\n    };\n\n    _this.mergeBuffers = function (channelBuffer, recordingLength) {\n      var result = new Float32Array(recordingLength);\n      var offset = 0;\n      var lng = channelBuffer.length;\n\n      for (var i = 0; i < lng; i++) {\n        var buffer = channelBuffer[i];\n        result.set(buffer, offset);\n        offset += buffer.length;\n      }\n\n      return result;\n    };\n\n    _this.interleave = function (leftChannel, rightChannel) {\n      var length = leftChannel.length + rightChannel.length;\n      var result = new Float32Array(length);\n      var inputIndex = 0;\n\n      for (var index = 0; index < length;) {\n        result[index++] = leftChannel[inputIndex];\n        result[index++] = rightChannel[inputIndex];\n        inputIndex++;\n      }\n\n      return result;\n    };\n\n    _this.writeUTFBytes = function (view, offset, string) {\n      var lng = string.length;\n\n      for (var i = 0; i < lng; i++) {\n        view.setUint8(offset + i, string.charCodeAt(i));\n      }\n    };\n\n    _this.visualize = function () {\n      var _this$props = _this.props,\n          backgroundColor = _this$props.backgroundColor,\n          foregroundColor = _this$props.foregroundColor;\n      _this.WIDTH = _this.canvas.width;\n      _this.HEIGHT = _this.canvas.height;\n      _this.CENTERX = _this.canvas.width / 2;\n      _this.CENTERY = _this.canvas.height / 2;\n      if (!_this.analyser) return;\n      _this.analyser.fftSize = 2048;\n      var bufferLength = _this.analyser.fftSize;\n      var dataArray = new Uint8Array(bufferLength);\n\n      _this.canvasCtx.clearRect(0, 0, _this.WIDTH, _this.HEIGHT);\n\n      var self = _assertThisInitialized(_this);\n\n      var draw = function draw() {\n        self.drawVisual = requestAnimationFrame(draw);\n        self.analyser.getByteTimeDomainData(dataArray);\n        self.canvasCtx.fillStyle = backgroundColor;\n        self.canvasCtx.fillRect(0, 0, self.WIDTH, self.HEIGHT);\n        self.canvasCtx.lineWidth = 2;\n        self.canvasCtx.strokeStyle = foregroundColor;\n        self.canvasCtx.beginPath();\n        var sliceWidth = self.WIDTH * 1.0 / bufferLength;\n        var x = 0;\n\n        for (var i = 0; i < bufferLength; i++) {\n          var v = dataArray[i] / 128.0;\n          var y = v * self.HEIGHT / 2;\n\n          if (i === 0) {\n            self.canvasCtx.moveTo(x, y);\n          } else {\n            self.canvasCtx.lineTo(x, y);\n          }\n\n          x += sliceWidth;\n        }\n\n        self.canvasCtx.lineTo(self.canvas.width, self.canvas.height / 2);\n        self.canvasCtx.stroke();\n      };\n\n      draw();\n    };\n\n    _this.setupMic = function () {\n      try {\n        var _temp3 = function _temp3() {\n          _this.setUpRecording();\n        };\n\n        var _temp4 = _catch(function () {\n          return Promise.resolve(_this.getStream()).then(function (_this$getStream) {\n            window.stream = _this.stream = _this$getStream;\n          });\n        }, function (err) {\n          console.log('Error: Issue getting mic', err);\n        });\n\n        return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    _this.start = function () {\n      try {\n        return Promise.resolve(_this.setupMic()).then(function () {\n          _this.recording = true;\n          _this.leftchannel.length = _this.rightchannel.length = 0;\n          _this.recordingLength = 0;\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    _this.stop = function () {\n      var _this$props2 = _this.props,\n          onStop = _this$props2.onStop,\n          type = _this$props2.type;\n      _this.recording = false;\n\n      _this.closeMic();\n\n      _this.leftBuffer = _this.mergeBuffers(_this.leftchannel, _this.recordingLength);\n      _this.rightBuffer = _this.mergeBuffers(_this.rightchannel, _this.recordingLength);\n\n      var interleaved = _this.interleave(_this.leftBuffer, _this.rightBuffer);\n\n      var buffer = new ArrayBuffer(44 + interleaved.length * 2);\n      var view = new DataView(buffer);\n\n      _this.writeUTFBytes(view, 0, 'RIFF');\n\n      view.setUint32(4, 44 + interleaved.length * 2, true);\n\n      _this.writeUTFBytes(view, 8, 'WAVE');\n\n      _this.writeUTFBytes(view, 12, 'fmt ');\n\n      view.setUint32(16, 16, true);\n      view.setUint16(20, 1, true);\n      view.setUint16(22, 2, true);\n      view.setUint32(24, _this.sampleRate, true);\n      view.setUint32(28, _this.sampleRate * 4, true);\n      view.setUint16(32, 4, true);\n      view.setUint16(34, 16, true);\n\n      _this.writeUTFBytes(view, 36, 'data');\n\n      view.setUint32(40, interleaved.length * 2, true);\n      var lng = interleaved.length;\n      var index = 44;\n      var volume = 1;\n\n      for (var i = 0; i < lng; i++) {\n        view.setInt16(index, interleaved[i] * (0x7fff * volume), true);\n        index += 2;\n      }\n\n      var blob = new Blob([view], {\n        type: type\n      });\n      var audioUrl = URL.createObjectURL(blob);\n      onStop && onStop({\n        blob: blob,\n        url: audioUrl,\n        type: type\n      });\n    };\n\n    _this.pause = function () {\n      _this.recording = false;\n\n      _this.closeMic();\n    };\n\n    _this.resume = function () {\n      _this.setupMic();\n\n      _this.recording = true;\n    };\n\n    _this.closeMic = function () {\n      _this.stream.getAudioTracks().forEach(function (track) {\n        track.stop();\n      });\n\n      _this.audioInput.disconnect(0);\n\n      _this.analyser.disconnect(0);\n\n      _this.recorder.disconnect(0);\n    };\n\n    _this.canvasRef = React.createRef();\n    return _this;\n  }\n\n  var _proto = AudioReactRecorder.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.init();\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var state = this.props.state;\n    this.checkState(prevProps.state, state);\n  };\n\n  _proto.checkState = function checkState(previousState) {\n    switch (previousState) {\n      case RecordState.START:\n        this.doIfState(RecordState.PAUSE, this.pause);\n        this.doIfState(RecordState.STOP, this.stop);\n        break;\n\n      case RecordState.PAUSE:\n        this.doIfState(RecordState.START, this.resume);\n        this.doIfState(RecordState.STOP, this.stop);\n        break;\n\n      case RecordState.STOP:\n        this.doIfState(RecordState.START, this.start);\n        break;\n\n      default:\n        this.doIfState(RecordState.START, this.start);\n        break;\n    }\n  };\n\n  _proto.doIfState = function doIfState(state, cb) {\n    if (this.props.state == state) {\n      cb && cb();\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {};\n\n  _proto.render = function render() {\n    var _this$props3 = this.props,\n        canvasWidth = _this$props3.canvasWidth,\n        canvasHeight = _this$props3.canvasHeight;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"audio-react-recorder\"\n    }, /*#__PURE__*/React.createElement(\"canvas\", {\n      ref: this.canvasRef,\n      width: canvasWidth,\n      height: canvasHeight,\n      className: \"audio-react-recorder__canvas\"\n    }));\n  };\n\n  return AudioReactRecorder;\n}(React.Component);\n\nAudioReactRecorder.propTypes = {\n  state: PropTypes.string,\n  type: PropTypes.string.isRequired,\n  backgroundColor: PropTypes.string,\n  foregroundColor: PropTypes.string,\n  canvasWidth: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  canvasHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  onStop: PropTypes.func\n};\nAudioReactRecorder.defaultProps = {\n  state: RecordState.NONE,\n  type: 'audio/wav',\n  backgroundColor: 'rgb(200, 200, 200)',\n  foregroundColor: 'rgb(0, 0, 0)',\n  canvasWidth: 500,\n  canvasHeight: 300\n};\nexport default AudioReactRecorder;\nexport { RecordState };","map":{"version":3,"sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/index.js"],"names":["RecordState","START","PAUSE","STOP","NONE","AudioReactRecorder","React","Component","propTypes","state","PropTypes","type","backgroundColor","foregroundColor","canvasWidth","canvasHeight","onStop","func","defaultProps","componentDidMount","componentDidUpdate","prevProps","checkState","doIfState","cb","componentWillUnmount","window","navigator","constraints","audio","video","bufferSize","self","left","e","right","a","console","track","result","offset","lng","channelBuffer","i","buffer","length","leftChannel","rightChannel","inputIndex","index","string","view","bufferLength","dataArray","draw","requestAnimationFrame","sliceWidth","x","v","y","interleaved","volume","blob","audioUrl","URL","url","render"],"mappings":"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","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import React from 'react'\r\nimport styles from './styles.module.css'\r\nimport PropTypes from 'prop-types' // ES6\r\n\r\n// export const AudioReactRecorder = ({ text }) => {\r\n//   return <div className={styles.test}>BULLSWEET: {text}</div>\r\n// }\r\n\r\nexport const RecordState = Object.freeze({\r\n  START: 'start',\r\n  PAUSE: 'pause',\r\n  STOP: 'stop',\r\n  NONE: 'none'\r\n})\r\n\r\nexport default class AudioReactRecorder extends React.Component {\r\n  //0 - constructor\r\n  constructor(props) {\r\n    super(props)\r\n\r\n    this.canvasRef = React.createRef()\r\n  }\r\n\r\n  //TODO: add the props definitions\r\n  static propTypes = {\r\n    state: PropTypes.string,\r\n    type: PropTypes.string.isRequired,\r\n    backgroundColor: PropTypes.string,\r\n    foregroundColor: PropTypes.string,\r\n    canvasWidth: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\r\n    canvasHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\r\n\r\n    //method calls\r\n    onStop: PropTypes.func\r\n  }\r\n  static defaultProps = {\r\n    state: RecordState.NONE,\r\n    type: 'audio/wav',\r\n    backgroundColor: 'rgb(200, 200, 200)',\r\n    foregroundColor: 'rgb(0, 0, 0)',\r\n    canvasWidth: 500,\r\n    canvasHeight: 300\r\n  }\r\n\r\n  //2 - mount\r\n  componentDidMount() {\r\n    this.init()\r\n  }\r\n\r\n  componentDidUpdate(prevProps, prevState) {\r\n    const { state } = this.props\r\n\r\n    this.checkState(prevProps.state, state)\r\n  }\r\n\r\n  checkState(previousState) {\r\n    switch (previousState) {\r\n      case RecordState.START:\r\n        this.doIfState(RecordState.PAUSE, this.pause)\r\n        this.doIfState(RecordState.STOP, this.stop)\r\n        break\r\n      case RecordState.PAUSE:\r\n        this.doIfState(RecordState.START, this.resume)\r\n        this.doIfState(RecordState.STOP, this.stop)\r\n        break\r\n      case RecordState.STOP:\r\n        this.doIfState(RecordState.START, this.start)\r\n        break\r\n      default:\r\n        this.doIfState(RecordState.START, this.start)\r\n        break\r\n    }\r\n  }\r\n\r\n  doIfState(state, cb) {\r\n    if (this.props.state == state) {\r\n      cb && cb()\r\n    }\r\n  }\r\n\r\n  //TODO: destroy request animation frame\r\n  componentWillUnmount() {}\r\n\r\n  //TODO: change to state some conditionals\r\n  init = async () => {\r\n    this.leftchannel = []\r\n    this.rightchannel = []\r\n    this.recorder = null\r\n    this.recording = false\r\n    this.recordingLength = 0\r\n    this.volume = null\r\n    this.audioInput = null\r\n    this.sampleRate = null\r\n    this.AudioContext = window.AudioContext || window.webkitAudioContext\r\n    this.context = null\r\n    this.analyser = null\r\n    this.canvas = this.canvasRef.current\r\n    this.canvasCtx = this.canvas.getContext('2d')\r\n    this.stream = null\r\n    this.tested = false\r\n\r\n    navigator.getUserMedia =\r\n      navigator.getUserMedia ||\r\n      navigator.webkitGetUserMedia ||\r\n      navigator.mozGetUserMedia\r\n  }\r\n\r\n  //get mic stream\r\n  getStream = (constraints) => {\r\n    if (!constraints) {\r\n      constraints = { audio: true, video: false }\r\n    }\r\n\r\n    return navigator.mediaDevices.getUserMedia(constraints)\r\n  }\r\n\r\n  setUpRecording = () => {\r\n    this.context = new this.AudioContext()\r\n    this.sampleRate = this.context.sampleRate\r\n\r\n    // creates a gain node\r\n    this.volume = this.context.createGain()\r\n\r\n    // creates an audio node from teh microphone incoming stream\r\n    this.audioInput = this.context.createMediaStreamSource(this.stream)\r\n\r\n    // Create analyser\r\n    this.analyser = this.context.createAnalyser()\r\n\r\n    // connect audio input to the analyser\r\n    this.audioInput.connect(this.analyser)\r\n\r\n    // connect analyser to the volume control\r\n    // analyser.connect(volume);\r\n\r\n    let bufferSize = 2048\r\n    this.recorder = this.context.createScriptProcessor(bufferSize, 2, 2)\r\n\r\n    // we connect the volume control to the processor\r\n    // volume.connect(recorder);\r\n\r\n    this.analyser.connect(this.recorder)\r\n\r\n    // finally connect the processor to the output\r\n    this.recorder.connect(this.context.destination)\r\n\r\n    const self = this\r\n    this.recorder.onaudioprocess = function (e) {\r\n      // Check\r\n      if (!self.recording) return\r\n      // Do something with the data, i.e Convert this to WAV\r\n      let left = e.inputBuffer.getChannelData(0)\r\n      let right = e.inputBuffer.getChannelData(1)\r\n      if (!self.tested) {\r\n        self.tested = true\r\n        // if this reduces to 0 we are not getting any sound\r\n        if (!left.reduce((a, b) => a + b)) {\r\n          console.log('Error: There seems to be an issue with your Mic')\r\n          // clean up;\r\n          self.stop()\r\n          self.stream.getTracks().forEach(function (track) {\r\n            track.stop()\r\n          })\r\n          self.context.close()\r\n        }\r\n      }\r\n      // we clone the samples\r\n      self.leftchannel.push(new Float32Array(left))\r\n      self.rightchannel.push(new Float32Array(right))\r\n      self.recordingLength += bufferSize\r\n    }\r\n    this.visualize()\r\n  }\r\n\r\n  mergeBuffers = (channelBuffer, recordingLength) => {\r\n    let result = new Float32Array(recordingLength)\r\n    let offset = 0\r\n    let lng = channelBuffer.length\r\n    for (let i = 0; i < lng; i++) {\r\n      let buffer = channelBuffer[i]\r\n      result.set(buffer, offset)\r\n      offset += buffer.length\r\n    }\r\n    return result\r\n  }\r\n\r\n  interleave = (leftChannel, rightChannel) => {\r\n    let length = leftChannel.length + rightChannel.length\r\n    let result = new Float32Array(length)\r\n\r\n    let inputIndex = 0\r\n\r\n    for (let index = 0; index < length; ) {\r\n      result[index++] = leftChannel[inputIndex]\r\n      result[index++] = rightChannel[inputIndex]\r\n      inputIndex++\r\n    }\r\n    return result\r\n  }\r\n\r\n  writeUTFBytes = (view, offset, string) => {\r\n    let lng = string.length\r\n    for (let i = 0; i < lng; i++) {\r\n      view.setUint8(offset + i, string.charCodeAt(i))\r\n    }\r\n  }\r\n\r\n  visualize = () => {\r\n    const { backgroundColor, foregroundColor } = this.props\r\n\r\n    this.WIDTH = this.canvas.width\r\n    this.HEIGHT = this.canvas.height\r\n    this.CENTERX = this.canvas.width / 2\r\n    this.CENTERY = this.canvas.height / 2\r\n\r\n    if (!this.analyser) return\r\n\r\n    this.analyser.fftSize = 2048\r\n    const bufferLength = this.analyser.fftSize\r\n    const dataArray = new Uint8Array(bufferLength)\r\n\r\n    this.canvasCtx.clearRect(0, 0, this.WIDTH, this.HEIGHT)\r\n\r\n    //reference this using self\r\n    let self = this\r\n    const draw = function () {\r\n      self.drawVisual = requestAnimationFrame(draw)\r\n\r\n      self.analyser.getByteTimeDomainData(dataArray)\r\n\r\n      self.canvasCtx.fillStyle = backgroundColor\r\n      self.canvasCtx.fillRect(0, 0, self.WIDTH, self.HEIGHT)\r\n\r\n      self.canvasCtx.lineWidth = 2\r\n      self.canvasCtx.strokeStyle = foregroundColor\r\n\r\n      self.canvasCtx.beginPath()\r\n\r\n      var sliceWidth = (self.WIDTH * 1.0) / bufferLength\r\n      var x = 0\r\n\r\n      for (var i = 0; i < bufferLength; i++) {\r\n        var v = dataArray[i] / 128.0\r\n        var y = (v * self.HEIGHT) / 2\r\n\r\n        if (i === 0) {\r\n          self.canvasCtx.moveTo(x, y)\r\n        } else {\r\n          self.canvasCtx.lineTo(x, y)\r\n        }\r\n\r\n        x += sliceWidth\r\n      }\r\n\r\n      self.canvasCtx.lineTo(self.canvas.width, self.canvas.height / 2)\r\n      self.canvasCtx.stroke()\r\n    }\r\n\r\n    draw()\r\n  }\r\n\r\n  setupMic = async () => {\r\n    //TODO: only get stream after clicking start\r\n    try {\r\n      window.stream = this.stream = await this.getStream()\r\n      //TODO: on got stream\r\n    } catch (err) {\r\n      //TODO: error getting stream\r\n      console.log('Error: Issue getting mic', err)\r\n    }\r\n\r\n    this.setUpRecording()\r\n  }\r\n\r\n  start = async () => {\r\n    await this.setupMic()\r\n\r\n    this.recording = true\r\n    // reset the buffers for the new recording\r\n    this.leftchannel.length = this.rightchannel.length = 0\r\n    this.recordingLength = 0\r\n  }\r\n\r\n  stop = () => {\r\n    const { onStop, type } = this.props\r\n\r\n    this.recording = false\r\n    this.closeMic()\r\n\r\n    // we flat the left and right channels down\r\n    this.leftBuffer = this.mergeBuffers(this.leftchannel, this.recordingLength)\r\n    this.rightBuffer = this.mergeBuffers(\r\n      this.rightchannel,\r\n      this.recordingLength\r\n    )\r\n    // we interleave both channels together\r\n    let interleaved = this.interleave(this.leftBuffer, this.rightBuffer)\r\n\r\n    ///////////// WAV Encode /////////////////\r\n    // from http://typedarray.org/from-microphone-to-wav-with-getusermedia-and-web-audio/\r\n    //\r\n\r\n    // we create our wav file\r\n    let buffer = new ArrayBuffer(44 + interleaved.length * 2)\r\n    let view = new DataView(buffer)\r\n\r\n    // RIFF chunk descriptor\r\n    this.writeUTFBytes(view, 0, 'RIFF')\r\n    view.setUint32(4, 44 + interleaved.length * 2, true)\r\n    this.writeUTFBytes(view, 8, 'WAVE')\r\n    // FMT sub-chunk\r\n    this.writeUTFBytes(view, 12, 'fmt ')\r\n    view.setUint32(16, 16, true)\r\n    view.setUint16(20, 1, true)\r\n    // stereo (2 channels)\r\n    view.setUint16(22, 2, true)\r\n    view.setUint32(24, this.sampleRate, true)\r\n    view.setUint32(28, this.sampleRate * 4, true)\r\n    view.setUint16(32, 4, true)\r\n    view.setUint16(34, 16, true)\r\n    // data sub-chunk\r\n    this.writeUTFBytes(view, 36, 'data')\r\n    view.setUint32(40, interleaved.length * 2, true)\r\n\r\n    // write the PCM samples\r\n    let lng = interleaved.length\r\n    let index = 44\r\n    let volume = 1\r\n    for (let i = 0; i < lng; i++) {\r\n      view.setInt16(index, interleaved[i] * (0x7fff * volume), true)\r\n      index += 2\r\n    }\r\n\r\n    // our final binary blob\r\n    const blob = new Blob([view], { type: type })\r\n    const audioUrl = URL.createObjectURL(blob)\r\n\r\n    onStop &&\r\n      onStop({\r\n        blob: blob,\r\n        url: audioUrl,\r\n        type\r\n      })\r\n  }\r\n\r\n  pause = () => {\r\n    this.recording = false\r\n    this.closeMic()\r\n  }\r\n\r\n  resume = () => {\r\n    this.setupMic()\r\n    this.recording = true\r\n  }\r\n\r\n  closeMic = () => {\r\n    this.stream.getAudioTracks().forEach((track) => {\r\n      track.stop()\r\n    })\r\n    this.audioInput.disconnect(0)\r\n    this.analyser.disconnect(0)\r\n    this.recorder.disconnect(0)\r\n  }\r\n\r\n  //1 - render\r\n  render() {\r\n    const { canvasWidth, canvasHeight } = this.props\r\n\r\n    return (\r\n      <div className='audio-react-recorder'>\r\n        <canvas\r\n          ref={this.canvasRef}\r\n          width={canvasWidth}\r\n          height={canvasHeight}\r\n          className='audio-react-recorder__canvas'\r\n        ></canvas>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}